# Workouts Implementation Plan

Based on the spec defined in `packages/core/_specs_/contexts/training/workouts.md`.

## Requirements

1. **Workout aggregate**: Add missing methods `finish()`, `belongsTo(userId)`, `isFinished()` to the existing Workout class
2. **Domain errors**: Create `WorkoutDoesNotExistError` and `WorkoutAlreadyFinishedError`
3. **FindWorkout**: Domain helper use case that finds a workout by ID or throws `WorkoutDoesNotExistError`
4. **SearchWorkoutsByUser**: Application use case that returns all workouts for a user as primitives
5. **StartWorkoutFromRoutine**: Application use case that copies a routine's structure into a new workout (blocks, sets, metrics) and persists it
6. **DiscardWorkout**: Application use case that deletes an unfinished workout after verifying ownership
7. **FinishWorkout**: Application use case that marks a workout as finished after verifying ownership and not-finished state
8. **Test infrastructure**: Mothers, mocks, and full test coverage for all use cases

## Folder Structure

```
packages/core/
├── tests/contexts/training/
│   └── workouts/
│       ├── domain/
│       │   ├── workout-id-mother.ts                                    # NEW
│       │   ├── workout-mother.ts                                       # NEW
│       │   ├── mock-workout-repository.ts                              # NEW
│       │   └── find-workout.test.ts                                    # NEW
│       └── application/
│           ├── search-workouts-by-user.test.ts                         # NEW
│           ├── start-workout-from-routine.test.ts                      # NEW
│           ├── discard-workout.test.ts                                 # NEW
│           └── finish-workout.test.ts                                  # NEW
└── src/contexts/training/
    └── workouts/
        ├── domain/
        │   ├── workout.ts                                              # UPDATE: add finish(), belongsTo(), isFinished()
        │   ├── workout-does-not-exist-error.ts                         # NEW
        │   ├── workout-already-finished-error.ts                       # NEW
        │   └── find-workout.usecase.ts                                 # NEW
        └── application/
            ├── search-workouts-by-user.usecase.ts                      # NEW
            ├── start-workout-from-routine.usecase.ts                   # NEW
            ├── discard-workout.usecase.ts                              # NEW
            └── finish-workout.usecase.ts                               # NEW
```

## Implementation Details

### Test Infrastructure

#### `tests/contexts/training/workouts/domain/workout-id-mother.ts`

```typescript
import { IdMother } from "../../../../shared/domain/id-mother";

export class WorkoutIdMother extends IdMother {}
```

#### `tests/contexts/training/workouts/domain/workout-mother.ts`

```typescript
import { faker } from "@faker-js/faker";
import {
  Workout,
  type WorkoutPrimitives,
} from "../../../../../src/contexts/training/workouts/domain/workout";
import type { WorkoutBlockPrimitives } from "../../../../../src/contexts/training/workouts/domain/workout-block";
import { WorkoutIdMother } from "./workout-id-mother";
import { TimestampMother } from "../../../../shared/domain/timestamp-mother";

export class WorkoutMother {
  static create(params?: Partial<WorkoutPrimitives>): Workout {
    const primitives: WorkoutPrimitives = {
      id: WorkoutIdMother.random().value,
      userId: WorkoutIdMother.random().value,
      routineId: null,
      name: faker.lorem.words(3),
      startedAt: TimestampMother.random().value,
      finishedAt: null,
      notes: null,
      blocks: [],
      createdAt: TimestampMother.random().value,
      updatedAt: TimestampMother.random().value,
      ...params,
    };
    return Workout.fromPrimitives(primitives);
  }

  static createFinished(params?: Partial<WorkoutPrimitives>): Workout {
    return WorkoutMother.create({
      finishedAt: TimestampMother.random().value,
      ...params,
    });
  }

  static createWithBlocks(
    blocks: WorkoutBlockPrimitives[],
    params?: Partial<WorkoutPrimitives>,
  ): Workout {
    return WorkoutMother.create({
      blocks,
      ...params,
    });
  }
}
```

#### `tests/contexts/training/workouts/domain/mock-workout-repository.ts`

```typescript
import { mock } from "bun:test";
import type { Workout } from "../../../../../src/contexts/training/workouts/domain/workout";
import { WorkoutRepository } from "../../../../../src/contexts/training/workouts/domain/workout-repository";

export class MockWorkoutRepository extends WorkoutRepository {
  readonly save = mock(() => Promise.resolve());
  readonly search = mock(() => Promise.resolve(null));
  readonly searchByUserId = mock(() => Promise.resolve([]));
  readonly delete = mock(() => Promise.resolve());

  returnOnSearch(workout: Workout | null): void {
    this.search.mockResolvedValue(workout);
  }

  returnOnSearchByUserId(workouts: Workout[]): void {
    this.searchByUserId.mockResolvedValue(workouts);
  }
}
```

### Domain Tests

#### `tests/contexts/training/workouts/domain/find-workout.test.ts`

```typescript
import { describe, it, expect, beforeEach } from "bun:test";
import { FindWorkout } from "../../../../../src/contexts/training/workouts/domain/find-workout.usecase";
import { WorkoutDoesNotExistError } from "../../../../../src/contexts/training/workouts/domain/workout-does-not-exist-error";
import { WorkoutMother } from "./workout-mother";
import { WorkoutIdMother } from "./workout-id-mother";
import { MockWorkoutRepository } from "./mock-workout-repository";

describe("FindWorkout", () => {
  let repository: MockWorkoutRepository;
  let usecase: FindWorkout;

  beforeEach(() => {
    repository = new MockWorkoutRepository();
    usecase = new FindWorkout(repository);
  });

  it("returns the workout when it exists", async () => {
    const workout = WorkoutMother.create();
    const workoutId = workout.toPrimitives().id;
    repository.returnOnSearch(workout);

    const result = await usecase.execute({ id: workoutId });

    expect(result.toPrimitives()).toEqual(workout.toPrimitives());
  });

  it("throws WorkoutDoesNotExistError when workout does not exist", async () => {
    const workoutId = WorkoutIdMother.random().value;
    repository.returnOnSearch(null);

    expect(usecase.execute({ id: workoutId })).rejects.toBeInstanceOf(
      WorkoutDoesNotExistError,
    );
  });
});
```

### Application Tests

#### `tests/contexts/training/workouts/application/search-workouts-by-user.test.ts`

```typescript
import { describe, it, expect, beforeEach } from "bun:test";
import { SearchWorkoutsByUser } from "../../../../../src/contexts/training/workouts/application/search-workouts-by-user.usecase";
import { WorkoutMother } from "../domain/workout-mother";
import { MockWorkoutRepository } from "../domain/mock-workout-repository";

describe("SearchWorkoutsByUser", () => {
  let repository: MockWorkoutRepository;
  let usecase: SearchWorkoutsByUser;

  beforeEach(() => {
    repository = new MockWorkoutRepository();
    usecase = new SearchWorkoutsByUser(repository);
  });

  it("returns all workouts for the user as primitives", async () => {
    const userId = "user-1";
    const workouts = [
      WorkoutMother.create({ userId }),
      WorkoutMother.create({ userId }),
    ];
    repository.returnOnSearchByUserId(workouts);

    const result = await usecase.execute({ userId });

    expect(result).toEqual(workouts.map((w) => w.toPrimitives()));
  });

  it("returns empty list when user has no workouts", async () => {
    repository.returnOnSearchByUserId([]);

    const result = await usecase.execute({ userId: "user-1" });

    expect(result).toEqual([]);
  });
});
```

#### `tests/contexts/training/workouts/application/start-workout-from-routine.test.ts`

```typescript
import { describe, it, expect, beforeEach } from "bun:test";
import { StartWorkoutFromRoutine } from "../../../../../src/contexts/training/workouts/application/start-workout-from-routine.usecase";
import { FindRoutine } from "../../../../../src/contexts/training/routines/domain/find-routine.usecase";
import { RoutineDoesNotExistError } from "../../../../../src/contexts/training/routines/domain/routine-does-not-exist-error";
import { UnauthorizedResourceAccessError } from "../../../../../src/shared/domain/unauthorized-resource-access-error";
import { RoutineMother } from "../../routines/domain/routine-mother";
import { MockRoutineRepository } from "../../routines/domain/mock-routine-repository";
import { MockWorkoutRepository } from "../domain/mock-workout-repository";
import { WorkoutIdMother } from "../domain/workout-id-mother";
import type { RoutineBlockPrimitives } from "../../../../../src/contexts/training/routines/domain/routine-block";

describe("StartWorkoutFromRoutine", () => {
  let workoutRepository: MockWorkoutRepository;
  let routineRepository: MockRoutineRepository;
  let findRoutine: FindRoutine;
  let usecase: StartWorkoutFromRoutine;

  beforeEach(() => {
    workoutRepository = new MockWorkoutRepository();
    routineRepository = new MockRoutineRepository();
    findRoutine = new FindRoutine(routineRepository);
    usecase = new StartWorkoutFromRoutine(workoutRepository, findRoutine);
  });

  it("copies routine structure into a new workout and persists it", async () => {
    const userId = "user-1";
    const routineBlocks: RoutineBlockPrimitives[] = [
      {
        order: 1,
        notes: "Warm-up block",
        defaultRestTime: 60,
        sets: [
          {
            order: 1,
            exerciseId: "exercise-1",
            notes: "Go slow",
            restTime: null,
            metrics: [
              {
                metricId: "metric-1",
                targetRange: { min: { value: 8, unit: "quantity" }, max: { value: 12, unit: "quantity" } },
                targetValue: null,
                lastValue: { value: 10, unit: "quantity" },
              },
            ],
          },
          {
            order: 2,
            exerciseId: "exercise-2",
            notes: null,
            restTime: null,
            metrics: [],
          },
        ],
      },
    ];
    const routine = RoutineMother.create({
      userId,
      blocks: routineBlocks,
    });
    const routinePrimitives = routine.toPrimitives();
    routineRepository.returnOnSearch(routine);

    const workoutId = WorkoutIdMother.random().value;

    await usecase.execute({
      workoutId,
      userId,
      routineId: routinePrimitives.id,
    });

    expect(workoutRepository.save).toHaveBeenCalledTimes(1);
    const savedWorkout = workoutRepository.save.mock.calls[0][0];
    const savedPrimitives = savedWorkout.toPrimitives();

    expect(savedPrimitives.id).toBe(workoutId);
    expect(savedPrimitives.userId).toBe(userId);
    expect(savedPrimitives.routineId).toBe(routinePrimitives.id);
    expect(savedPrimitives.name).toBe(routinePrimitives.name);
    expect(savedPrimitives.finishedAt).toBeNull();
    expect(savedPrimitives.blocks).toHaveLength(1);

    const block = savedPrimitives.blocks[0];
    expect(block.order).toBe(1);
    expect(block.notes).toBe("Warm-up block");
    expect(block.startedAt).toBeNull();
    expect(block.finishedAt).toBeNull();
    expect(block.sets).toHaveLength(2);

    const set1 = block.sets[0];
    expect(set1.order).toBe(1);
    expect(set1.exerciseId).toBe("exercise-1");
    expect(set1.notes).toBe("Go slow");
    expect(set1.restTime).toBe(60);
    expect(set1.startedAt).toBeNull();
    expect(set1.finishedAt).toBeNull();
    expect(set1.metrics).toHaveLength(1);
    expect(set1.metrics[0].metricId).toBe("metric-1");
    expect(set1.metrics[0].value).toEqual({ value: 0, unit: "quantity" });
    expect(set1.metrics[0].targetRange).toEqual({
      min: { value: 8, unit: "quantity" },
      max: { value: 12, unit: "quantity" },
    });
    expect(set1.metrics[0].targetValue).toBeNull();

    const set2 = block.sets[1];
    expect(set2.restTime).toBe(60);
    expect(set2.metrics).toHaveLength(0);
  });

  it("uses set-level rest time when it overrides block default", async () => {
    const userId = "user-1";
    const routineBlocks: RoutineBlockPrimitives[] = [
      {
        order: 1,
        notes: null,
        defaultRestTime: 60,
        sets: [
          {
            order: 1,
            exerciseId: "exercise-1",
            notes: null,
            restTime: 90,
            metrics: [],
          },
        ],
      },
    ];
    const routine = RoutineMother.create({
      userId,
      blocks: routineBlocks,
    });
    routineRepository.returnOnSearch(routine);

    const workoutId = WorkoutIdMother.random().value;

    await usecase.execute({
      workoutId,
      userId,
      routineId: routine.toPrimitives().id,
    });

    const savedWorkout = workoutRepository.save.mock.calls[0][0];
    const savedPrimitives = savedWorkout.toPrimitives();
    expect(savedPrimitives.blocks[0].sets[0].restTime).toBe(90);
  });

  it("throws RoutineDoesNotExistError when routine does not exist", async () => {
    routineRepository.returnOnSearch(null);

    expect(
      usecase.execute({
        workoutId: WorkoutIdMother.random().value,
        userId: "user-1",
        routineId: WorkoutIdMother.random().value,
      }),
    ).rejects.toBeInstanceOf(RoutineDoesNotExistError);
  });

  it("throws UnauthorizedResourceAccessError when routine does not belong to user", async () => {
    const routine = RoutineMother.create({ userId: "other-user" });
    routineRepository.returnOnSearch(routine);

    expect(
      usecase.execute({
        workoutId: WorkoutIdMother.random().value,
        userId: "user-1",
        routineId: routine.toPrimitives().id,
      }),
    ).rejects.toBeInstanceOf(UnauthorizedResourceAccessError);
  });
});
```

#### `tests/contexts/training/workouts/application/discard-workout.test.ts`

```typescript
import { describe, it, expect, beforeEach } from "bun:test";
import { DiscardWorkout } from "../../../../../src/contexts/training/workouts/application/discard-workout.usecase";
import { FindWorkout } from "../../../../../src/contexts/training/workouts/domain/find-workout.usecase";
import { WorkoutDoesNotExistError } from "../../../../../src/contexts/training/workouts/domain/workout-does-not-exist-error";
import { WorkoutAlreadyFinishedError } from "../../../../../src/contexts/training/workouts/domain/workout-already-finished-error";
import { UnauthorizedResourceAccessError } from "../../../../../src/shared/domain/unauthorized-resource-access-error";
import { WorkoutMother } from "../domain/workout-mother";
import { WorkoutIdMother } from "../domain/workout-id-mother";
import { MockWorkoutRepository } from "../domain/mock-workout-repository";

describe("DiscardWorkout", () => {
  let repository: MockWorkoutRepository;
  let findWorkout: FindWorkout;
  let usecase: DiscardWorkout;

  beforeEach(() => {
    repository = new MockWorkoutRepository();
    findWorkout = new FindWorkout(repository);
    usecase = new DiscardWorkout(repository, findWorkout);
  });

  it("deletes an ongoing workout owned by the user", async () => {
    const userId = "user-1";
    const workout = WorkoutMother.create({ userId });
    const workoutId = workout.toPrimitives().id;
    repository.returnOnSearch(workout);

    await usecase.execute({ userId, workoutId });

    expect(repository.delete).toHaveBeenCalledTimes(1);
  });

  it("throws WorkoutDoesNotExistError when workout does not exist", async () => {
    const workoutId = WorkoutIdMother.random().value;
    repository.returnOnSearch(null);

    expect(
      usecase.execute({ userId: "user-1", workoutId }),
    ).rejects.toBeInstanceOf(WorkoutDoesNotExistError);
  });

  it("throws UnauthorizedResourceAccessError when workout does not belong to user", async () => {
    const workout = WorkoutMother.create({ userId: "other-user" });
    const workoutId = workout.toPrimitives().id;
    repository.returnOnSearch(workout);

    expect(
      usecase.execute({ userId: "user-1", workoutId }),
    ).rejects.toBeInstanceOf(UnauthorizedResourceAccessError);
  });

  it("throws WorkoutAlreadyFinishedError when workout is already finished", async () => {
    const userId = "user-1";
    const workout = WorkoutMother.createFinished({ userId });
    const workoutId = workout.toPrimitives().id;
    repository.returnOnSearch(workout);

    expect(
      usecase.execute({ userId, workoutId }),
    ).rejects.toBeInstanceOf(WorkoutAlreadyFinishedError);
  });
});
```

#### `tests/contexts/training/workouts/application/finish-workout.test.ts`

```typescript
import { describe, it, expect, beforeEach } from "bun:test";
import { FinishWorkout } from "../../../../../src/contexts/training/workouts/application/finish-workout.usecase";
import { FindWorkout } from "../../../../../src/contexts/training/workouts/domain/find-workout.usecase";
import { WorkoutDoesNotExistError } from "../../../../../src/contexts/training/workouts/domain/workout-does-not-exist-error";
import { WorkoutAlreadyFinishedError } from "../../../../../src/contexts/training/workouts/domain/workout-already-finished-error";
import { UnauthorizedResourceAccessError } from "../../../../../src/shared/domain/unauthorized-resource-access-error";
import { WorkoutMother } from "../domain/workout-mother";
import { WorkoutIdMother } from "../domain/workout-id-mother";
import { MockWorkoutRepository } from "../domain/mock-workout-repository";

describe("FinishWorkout", () => {
  let repository: MockWorkoutRepository;
  let findWorkout: FindWorkout;
  let usecase: FinishWorkout;

  beforeEach(() => {
    repository = new MockWorkoutRepository();
    findWorkout = new FindWorkout(repository);
    usecase = new FinishWorkout(repository, findWorkout);
  });

  it("finishes an ongoing workout owned by the user", async () => {
    const userId = "user-1";
    const workout = WorkoutMother.create({ userId });
    const workoutId = workout.toPrimitives().id;
    repository.returnOnSearch(workout);

    await usecase.execute({ userId, workoutId });

    expect(repository.save).toHaveBeenCalledTimes(1);
    const savedWorkout = repository.save.mock.calls[0][0];
    const savedPrimitives = savedWorkout.toPrimitives();
    expect(savedPrimitives.finishedAt).not.toBeNull();
  });

  it("throws WorkoutDoesNotExistError when workout does not exist", async () => {
    const workoutId = WorkoutIdMother.random().value;
    repository.returnOnSearch(null);

    expect(
      usecase.execute({ userId: "user-1", workoutId }),
    ).rejects.toBeInstanceOf(WorkoutDoesNotExistError);
  });

  it("throws UnauthorizedResourceAccessError when workout does not belong to user", async () => {
    const workout = WorkoutMother.create({ userId: "other-user" });
    const workoutId = workout.toPrimitives().id;
    repository.returnOnSearch(workout);

    expect(
      usecase.execute({ userId: "user-1", workoutId }),
    ).rejects.toBeInstanceOf(UnauthorizedResourceAccessError);
  });

  it("throws WorkoutAlreadyFinishedError when workout is already finished", async () => {
    const userId = "user-1";
    const workout = WorkoutMother.createFinished({ userId });
    const workoutId = workout.toPrimitives().id;
    repository.returnOnSearch(workout);

    expect(
      usecase.execute({ userId, workoutId }),
    ).rejects.toBeInstanceOf(WorkoutAlreadyFinishedError);
  });
});
```

### Domain Errors

#### `src/contexts/training/workouts/domain/workout-does-not-exist-error.ts`

```typescript
import { DomainError } from "../../../../shared/domain/domain-error";

export class WorkoutDoesNotExistError extends DomainError {
  readonly type = "WorkoutDoesNotExistError";
  readonly message: string;

  constructor(public readonly workoutId: string) {
    super();
    this.message = `The workout ${this.workoutId} does not exist`;
  }
}
```

#### `src/contexts/training/workouts/domain/workout-already-finished-error.ts`

```typescript
import { DomainError } from "../../../../shared/domain/domain-error";

export class WorkoutAlreadyFinishedError extends DomainError {
  readonly type = "WorkoutAlreadyFinishedError";
  readonly message: string;

  constructor(public readonly workoutId: string) {
    super();
    this.message = `The workout ${this.workoutId} is already finished`;
  }
}
```

### Domain Use Case

#### `src/contexts/training/workouts/domain/find-workout.usecase.ts`

```typescript
import { InferDependencies } from "../../../../../di/autoregister";
import type { Workout } from "./workout";
import { WorkoutDoesNotExistError } from "./workout-does-not-exist-error";
import { WorkoutId } from "./workout-id";
import { WorkoutRepository } from "./workout-repository";

@InferDependencies()
export class FindWorkout {
  constructor(private readonly repository: WorkoutRepository) {}

  async execute(params: { id: string }): Promise<Workout> {
    const workoutId = new WorkoutId(params.id);
    const workout = await this.repository.search(workoutId);
    if (!workout) throw new WorkoutDoesNotExistError(params.id);
    return workout;
  }
}
```

### Workout Aggregate Update

#### `src/contexts/training/workouts/domain/workout.ts` (UPDATE)

Add the following three methods to the `Workout` class, after the `toPrimitives()` method:

```typescript
  belongsTo(userId: string): boolean {
    return this.userId.value === userId;
  }

  isFinished(): boolean {
    return this.finishedAt !== null;
  }

  finish(): void {
    this.finishedAt = new Date();
    this.updatedAt = new Date();
  }
```

### Application Use Cases

#### `src/contexts/training/workouts/application/search-workouts-by-user.usecase.ts`

```typescript
import { InferDependencies } from "../../../../../di/autoregister";
import { UserId } from "../../users/domain/user-id";
import type { WorkoutPrimitives } from "../domain/workout";
import { WorkoutRepository } from "../domain/workout-repository";

@InferDependencies()
export class SearchWorkoutsByUser {
  constructor(private readonly repository: WorkoutRepository) {}

  async execute(params: { userId: string }): Promise<WorkoutPrimitives[]> {
    const userId = new UserId(params.userId);
    const workouts = await this.repository.searchByUserId(userId);
    return workouts.map((workout) => workout.toPrimitives());
  }
}
```

#### `src/contexts/training/workouts/application/start-workout-from-routine.usecase.ts`

```typescript
import { InferDependencies } from "../../../../../di/autoregister";
import { UnauthorizedResourceAccessError } from "../../../../shared/domain/unauthorized-resource-access-error";
import type { Routine } from "../../routines/domain/routine";
import type { RoutineBlockPrimitives } from "../../routines/domain/routine-block";
import type { RoutineSetPrimitives } from "../../routines/domain/routine-set";
import type { RoutineSetMetricPrimitives } from "../../routines/domain/routine-set-metric";
import { FindRoutine } from "../../routines/domain/find-routine.usecase";
import { Workout } from "../domain/workout";
import type { WorkoutBlockPrimitives } from "../domain/workout-block";
import type { WorkoutSetPrimitives } from "../domain/workout-set";
import type { WorkoutSetMetricPrimitives } from "../domain/workout-set-metric";
import { WorkoutRepository } from "../domain/workout-repository";

@InferDependencies()
export class StartWorkoutFromRoutine {
  constructor(
    private readonly repository: WorkoutRepository,
    private readonly findRoutine: FindRoutine,
  ) {}

  async execute(params: {
    workoutId: string;
    userId: string;
    routineId: string;
  }): Promise<void> {
    const routine = await this.findRoutine.execute({ id: params.routineId });
    this.ensureRoutineBelongsToUser(routine, params.routineId, params.userId);

    const routinePrimitives = routine.toPrimitives();
    const blocks = this.copyRoutineBlocks(routinePrimitives.blocks);

    const workout = Workout.create({
      id: params.workoutId,
      userId: params.userId,
      routineId: params.routineId,
      name: routinePrimitives.name,
      blocks,
    });

    await this.repository.save(workout);
  }

  private copyRoutineBlocks(
    routineBlocks: RoutineBlockPrimitives[],
  ): WorkoutBlockPrimitives[] {
    return routineBlocks.map((block) => ({
      order: block.order,
      notes: block.notes,
      startedAt: null,
      finishedAt: null,
      sets: this.copyRoutineSets(block.sets, block.defaultRestTime),
    }));
  }

  private copyRoutineSets(
    routineSets: RoutineSetPrimitives[],
    defaultRestTime: number | null,
  ): WorkoutSetPrimitives[] {
    return routineSets.map((set) => ({
      order: set.order,
      exerciseId: set.exerciseId,
      notes: set.notes,
      startedAt: null,
      finishedAt: null,
      restTime: set.restTime ?? defaultRestTime,
      metrics: this.copyRoutineMetrics(set.metrics),
    }));
  }

  private copyRoutineMetrics(
    routineMetrics: RoutineSetMetricPrimitives[],
  ): WorkoutSetMetricPrimitives[] {
    return routineMetrics.map((metric) => ({
      metricId: metric.metricId,
      value: this.defaultMetricValue(metric),
      targetRange: metric.targetRange,
      targetValue: metric.targetValue,
    }));
  }

  private defaultMetricValue(
    metric: RoutineSetMetricPrimitives,
  ): { value: number; unit: string } {
    const unit =
      metric.targetValue?.unit ??
      metric.targetRange?.min?.unit ??
      metric.targetRange?.max?.unit ??
      "quantity";
    return { value: 0, unit };
  }

  private ensureRoutineBelongsToUser(
    routine: Routine,
    routineId: string,
    userId: string,
  ): void {
    if (routine.belongsTo(userId)) return;
    throw new UnauthorizedResourceAccessError(routine.constructor, routineId);
  }
}
```

#### `src/contexts/training/workouts/application/discard-workout.usecase.ts`

```typescript
import { InferDependencies } from "../../../../../di/autoregister";
import { UnauthorizedResourceAccessError } from "../../../../shared/domain/unauthorized-resource-access-error";
import type { Workout } from "../domain/workout";
import { WorkoutAlreadyFinishedError } from "../domain/workout-already-finished-error";
import { WorkoutId } from "../domain/workout-id";
import { WorkoutRepository } from "../domain/workout-repository";
import { FindWorkout } from "../domain/find-workout.usecase";

@InferDependencies()
export class DiscardWorkout {
  constructor(
    private readonly repository: WorkoutRepository,
    private readonly findWorkout: FindWorkout,
  ) {}

  async execute(params: { userId: string; workoutId: string }): Promise<void> {
    const workout = await this.findWorkout.execute({ id: params.workoutId });
    this.ensureWorkoutBelongsToUser(workout, params.workoutId, params.userId);
    this.ensureWorkoutIsNotFinished(workout, params.workoutId);
    await this.repository.delete(new WorkoutId(params.workoutId));
  }

  private ensureWorkoutBelongsToUser(
    workout: Workout,
    workoutId: string,
    userId: string,
  ): void {
    if (workout.belongsTo(userId)) return;
    throw new UnauthorizedResourceAccessError(workout.constructor, workoutId);
  }

  private ensureWorkoutIsNotFinished(
    workout: Workout,
    workoutId: string,
  ): void {
    if (!workout.isFinished()) return;
    throw new WorkoutAlreadyFinishedError(workoutId);
  }
}
```

#### `src/contexts/training/workouts/application/finish-workout.usecase.ts`

```typescript
import { InferDependencies } from "../../../../../di/autoregister";
import { UnauthorizedResourceAccessError } from "../../../../shared/domain/unauthorized-resource-access-error";
import type { Workout } from "../domain/workout";
import { WorkoutAlreadyFinishedError } from "../domain/workout-already-finished-error";
import { WorkoutRepository } from "../domain/workout-repository";
import { FindWorkout } from "../domain/find-workout.usecase";

@InferDependencies()
export class FinishWorkout {
  constructor(
    private readonly repository: WorkoutRepository,
    private readonly findWorkout: FindWorkout,
  ) {}

  async execute(params: { userId: string; workoutId: string }): Promise<void> {
    const workout = await this.findWorkout.execute({ id: params.workoutId });
    this.ensureWorkoutBelongsToUser(workout, params.workoutId, params.userId);
    this.ensureWorkoutIsNotFinished(workout, params.workoutId);
    workout.finish();
    await this.repository.save(workout);
  }

  private ensureWorkoutBelongsToUser(
    workout: Workout,
    workoutId: string,
    userId: string,
  ): void {
    if (workout.belongsTo(userId)) return;
    throw new UnauthorizedResourceAccessError(workout.constructor, workoutId);
  }

  private ensureWorkoutIsNotFinished(
    workout: Workout,
    workoutId: string,
  ): void {
    if (!workout.isFinished()) return;
    throw new WorkoutAlreadyFinishedError(workoutId);
  }
}
```

## Cross-Module Dependencies

This diff depends on the following artifacts from other modules that must exist before compilation:

| Dependency | Module | File |
|------------|--------|------|
| `FindRoutine` | routines | `src/contexts/training/routines/domain/find-routine.usecase.ts` |
| `RoutineDoesNotExistError` | routines | `src/contexts/training/routines/domain/routine-does-not-exist-error.ts` |
| `UnauthorizedResourceAccessError` | shared | `src/shared/domain/unauthorized-resource-access-error.ts` |
| `Routine.belongsTo()` | routines | `src/contexts/training/routines/domain/routine.ts` |
| `RoutineMother` | routines (tests) | `tests/contexts/training/routines/domain/routine-mother.ts` |
| `MockRoutineRepository` | routines (tests) | `tests/contexts/training/routines/domain/mock-routine-repository.ts` |

Compile the **routines diff** before this one to ensure all cross-module dependencies are available.
