# Routines Implementation Plan

Based on the spec defined in `packages/core/_specs_/contexts/training/routines.md`.

## Requirements

1. **Routine aggregate**: Add missing methods — `belongsTo`, `updateName`, `updateDescription`, `updateBlocks`
2. **RoutineDoesNotExistError**: Domain error for when a routine is not found
3. **UnauthorizedResourceAccessError**: Shared domain error for ownership check failures (new shared file)
4. **FindRoutine**: Domain-layer helper that searches by ID and throws if not found
5. **SearchRoutinesByUser**: Application use case returning all user routines as primitives
6. **CreateRoutine**: Application use case that creates and persists a routine
7. **UpdateRoutine**: Application use case with two-part signature (params + payload) using PayloadHandlers pattern
8. **DeleteRoutine**: Application use case that verifies ownership then deletes
9. **Test infrastructure**: Mothers (routine, routine-id, user-id), mock repository, and tests for all use cases

## Analysis

The domain layer is partially complete:

- `routine-id.ts` - EXISTS
- `routine-name.ts` - EXISTS
- `routine-description.ts` - EXISTS
- `routine-set-metric.ts` - EXISTS
- `routine-set.ts` - EXISTS
- `routine-block.ts` - EXISTS
- `routine.ts` - EXISTS (missing `belongsTo`, `updateName`, `updateDescription`, `updateBlocks`)
- `routine-repository.ts` - EXISTS

What's missing:

- `routine-does-not-exist-error.ts` - Domain error
- `find-routine.usecase.ts` - Domain helper
- `search-routines-by-user.usecase.ts` - Application use case
- `create-routine.usecase.ts` - Application use case
- `update-routine.usecase.ts` - Application use case
- `delete-routine.usecase.ts` - Application use case
- `src/shared/domain/unauthorized-resource-access-error.ts` - Shared domain error
- All test files and mothers

## Folder Structure

```
packages/core/
├── tests/
│   └── contexts/
│       └── training/
│           └── routines/
│               ├── domain/
│               │   ├── routine-id-mother.ts                             # NEW
│               │   ├── routine-mother.ts                                # NEW
│               │   ├── mock-routine-repository.ts                       # NEW
│               │   └── find-routine.test.ts                             # NEW
│               └── application/
│                   ├── search-routines-by-user.test.ts                  # NEW
│                   ├── create-routine.test.ts                           # NEW
│                   ├── update-routine.test.ts                           # NEW
│                   └── delete-routine.test.ts                           # NEW
└── src/
    ├── shared/
    │   └── domain/
    │       └── unauthorized-resource-access-error.ts                    # NEW
    └── contexts/
        └── training/
            └── routines/
                ├── domain/
                │   ├── routine.ts                                       # UPDATE: add belongsTo, updateName, updateDescription, updateBlocks
                │   ├── routine-does-not-exist-error.ts                  # NEW
                │   └── find-routine.usecase.ts                          # NEW
                └── application/
                    ├── search-routines-by-user.usecase.ts               # NEW
                    ├── create-routine.usecase.ts                        # NEW
                    ├── update-routine.usecase.ts                        # NEW
                    └── delete-routine.usecase.ts                        # NEW
```

## Implementation Details

### Shared Domain

#### `src/shared/domain/unauthorized-resource-access-error.ts`

```typescript
import { DomainError } from "./domain-error";

type Constructor = new (...args: unknown[]) => unknown;

export class UnauthorizedResourceAccessError extends DomainError {
  readonly type = "UnauthorizedResourceAccessError";
  readonly message: string;

  constructor(
    public readonly resourceType: Constructor,
    public readonly resourceId: string,
  ) {
    super();
    this.message = `Unauthorized access to ${this.resourceType.name} ${this.resourceId}`;
  }
}
```

### Test Helpers

#### `tests/contexts/training/routines/domain/routine-id-mother.ts`

```typescript
import { IdMother } from "../../../../shared/domain/id-mother";

export class RoutineIdMother extends IdMother {}
```

#### `tests/contexts/training/routines/domain/routine-mother.ts`

```typescript
import { faker } from "@faker-js/faker";
import {
  Routine,
  type RoutinePrimitives,
} from "../../../../../src/contexts/training/routines/domain/routine";
import type { RoutineBlockPrimitives } from "../../../../../src/contexts/training/routines/domain/routine-block";
import { RoutineIdMother } from "./routine-id-mother";
import { TimestampMother } from "../../../../shared/domain/timestamp-mother";

export class RoutineMother {
  static create(params?: Partial<RoutinePrimitives>): Routine {
    const primitives: RoutinePrimitives = {
      id: RoutineIdMother.random().value,
      name: faker.lorem.words(3),
      description: faker.lorem.sentence(),
      userId: faker.string.uuid(),
      blocks: [],
      createdAt: TimestampMother.random().value,
      updatedAt: TimestampMother.random().value,
      ...params,
    };
    return Routine.fromPrimitives(primitives);
  }

  static withBlocks(
    params?: Partial<RoutinePrimitives>,
  ): Routine {
    return RoutineMother.create({
      blocks: [RoutineMother.blockPrimitives()],
      ...params,
    });
  }

  static blockPrimitives(
    overrides?: Partial<RoutineBlockPrimitives>,
  ): RoutineBlockPrimitives {
    return {
      order: 1,
      notes: faker.lorem.sentence(),
      defaultRestTime: faker.number.int({ min: 30, max: 120 }),
      sets: [
        {
          order: 1,
          exerciseId: faker.string.uuid(),
          notes: null,
          restTime: null,
          metrics: [
            {
              metricId: faker.string.uuid(),
              targetRange: null,
              targetValue: { value: 10, unit: "quantity" },
              lastValue: null,
            },
          ],
        },
      ],
      ...overrides,
    };
  }
}
```

#### `tests/contexts/training/routines/domain/mock-routine-repository.ts`

```typescript
import { mock } from "bun:test";
import type { Routine } from "../../../../../src/contexts/training/routines/domain/routine";
import { RoutineRepository } from "../../../../../src/contexts/training/routines/domain/routine-repository";

export class MockRoutineRepository extends RoutineRepository {
  readonly save = mock(() => {});
  readonly search = mock(() => {});
  readonly searchByUserId = mock(() => {});
  readonly delete = mock(() => {});

  returnOnSearch(routine: Routine | null): void {
    this.search.mockResolvedValue(routine);
  }

  returnOnSearchByUserId(routines: Routine[]): void {
    this.searchByUserId.mockResolvedValue(routines);
  }
}
```

### Tests

#### `tests/contexts/training/routines/domain/find-routine.test.ts`

```typescript
import { describe, it, expect, beforeEach } from "bun:test";
import { FindRoutine } from "../../../../../src/contexts/training/routines/domain/find-routine.usecase";
import { RoutineDoesNotExistError } from "../../../../../src/contexts/training/routines/domain/routine-does-not-exist-error";
import { RoutineMother } from "./routine-mother";
import { RoutineIdMother } from "./routine-id-mother";
import { MockRoutineRepository } from "./mock-routine-repository";

describe("FindRoutine", () => {
  let repository: MockRoutineRepository;
  let usecase: FindRoutine;

  beforeEach(() => {
    repository = new MockRoutineRepository();
    usecase = new FindRoutine(repository);
  });

  it("finds and returns the routine", async () => {
    const routine = RoutineMother.create();
    const primitives = routine.toPrimitives();
    repository.returnOnSearch(routine);

    const result = await usecase.execute({ id: primitives.id });

    expect(result.toPrimitives()).toEqual(primitives);
  });

  it("rejects if routine does not exist", async () => {
    const id = RoutineIdMother.random().value;
    repository.returnOnSearch(null);

    await expect(usecase.execute({ id })).rejects.toThrow(
      RoutineDoesNotExistError,
    );
  });
});
```

#### `tests/contexts/training/routines/application/search-routines-by-user.test.ts`

```typescript
import { describe, it, expect, beforeEach } from "bun:test";
import { SearchRoutinesByUser } from "../../../../../src/contexts/training/routines/application/search-routines-by-user.usecase";
import { RoutineMother } from "../domain/routine-mother";
import { MockRoutineRepository } from "../domain/mock-routine-repository";

describe("SearchRoutinesByUser", () => {
  let repository: MockRoutineRepository;
  let usecase: SearchRoutinesByUser;

  beforeEach(() => {
    repository = new MockRoutineRepository();
    usecase = new SearchRoutinesByUser(repository);
  });

  it("returns all routines for the user as primitives", async () => {
    const userId = "user-1";
    const routines = [
      RoutineMother.create({ userId }),
      RoutineMother.create({ userId }),
    ];
    repository.returnOnSearchByUserId(routines);

    const result = await usecase.execute({ userId });

    expect(result).toEqual(routines.map((r) => r.toPrimitives()));
  });

  it("returns empty list when user has no routines", async () => {
    repository.returnOnSearchByUserId([]);

    const result = await usecase.execute({ userId: "user-1" });

    expect(result).toEqual([]);
  });
});
```

#### `tests/contexts/training/routines/application/create-routine.test.ts`

```typescript
import { describe, it, expect, beforeEach } from "bun:test";
import { CreateRoutine } from "../../../../../src/contexts/training/routines/application/create-routine.usecase";
import { Routine } from "../../../../../src/contexts/training/routines/domain/routine";
import { RoutineMother } from "../domain/routine-mother";
import { RoutineIdMother } from "../domain/routine-id-mother";
import { MockRoutineRepository } from "../domain/mock-routine-repository";

describe("CreateRoutine", () => {
  let repository: MockRoutineRepository;
  let usecase: CreateRoutine;

  beforeEach(() => {
    repository = new MockRoutineRepository();
    usecase = new CreateRoutine(repository);
  });

  it("creates routine with blocks and sets and persists it", async () => {
    const id = RoutineIdMother.random().value;
    const blocks = [RoutineMother.blockPrimitives()];

    await usecase.execute({
      id,
      userId: "user-1",
      name: "Push Pull Legs",
      description: "A PPL routine",
      blocks,
    });

    expect(repository.save).toHaveBeenCalledTimes(1);
    const savedRoutine = (repository.save as ReturnType<typeof import("bun:test").mock>).mock.calls[0][0] as Routine;
    const primitives = savedRoutine.toPrimitives();
    expect(primitives.id).toBe(id);
    expect(primitives.name).toBe("Push Pull Legs");
    expect(primitives.description).toBe("A PPL routine");
    expect(primitives.userId).toBe("user-1");
    expect(primitives.blocks).toEqual(blocks);
  });

  it("creates routine with empty blocks", async () => {
    const id = RoutineIdMother.random().value;

    await usecase.execute({
      id,
      userId: "user-1",
      name: "Empty Routine",
      description: null,
      blocks: [],
    });

    expect(repository.save).toHaveBeenCalledTimes(1);
    const savedRoutine = (repository.save as ReturnType<typeof import("bun:test").mock>).mock.calls[0][0] as Routine;
    const primitives = savedRoutine.toPrimitives();
    expect(primitives.blocks).toEqual([]);
    expect(primitives.description).toBeNull();
  });
});
```

#### `tests/contexts/training/routines/application/update-routine.test.ts`

```typescript
import { describe, it, expect, beforeEach } from "bun:test";
import { UpdateRoutine } from "../../../../../src/contexts/training/routines/application/update-routine.usecase";
import { FindRoutine } from "../../../../../src/contexts/training/routines/domain/find-routine.usecase";
import { RoutineDoesNotExistError } from "../../../../../src/contexts/training/routines/domain/routine-does-not-exist-error";
import { UnauthorizedResourceAccessError } from "../../../../../src/shared/domain/unauthorized-resource-access-error";
import { RoutineMother } from "../domain/routine-mother";
import { RoutineIdMother } from "../domain/routine-id-mother";
import { MockRoutineRepository } from "../domain/mock-routine-repository";

describe("UpdateRoutine", () => {
  const userId = "user-1";

  let repository: MockRoutineRepository;
  let findRoutine: FindRoutine;
  let usecase: UpdateRoutine;

  beforeEach(() => {
    repository = new MockRoutineRepository();
    findRoutine = new FindRoutine(repository);
    usecase = new UpdateRoutine(repository, findRoutine);
  });

  it("updates routine name only", async () => {
    const routine = RoutineMother.create({ userId });
    const routineId = routine.toPrimitives().id;
    repository.returnOnSearch(routine);

    await usecase.execute(
      { userId, routineId },
      { name: "New Name" },
    );

    expect(repository.save).toHaveBeenCalledTimes(1);
    const saved = (repository.save as ReturnType<typeof import("bun:test").mock>).mock.calls[0][0];
    expect(saved.toPrimitives().name).toBe("New Name");
  });

  it("updates routine blocks only", async () => {
    const routine = RoutineMother.create({ userId });
    const routineId = routine.toPrimitives().id;
    repository.returnOnSearch(routine);
    const newBlocks = [RoutineMother.blockPrimitives()];

    await usecase.execute(
      { userId, routineId },
      { blocks: newBlocks },
    );

    expect(repository.save).toHaveBeenCalledTimes(1);
    const saved = (repository.save as ReturnType<typeof import("bun:test").mock>).mock.calls[0][0];
    expect(saved.toPrimitives().blocks).toEqual(newBlocks);
  });

  it("updates all fields", async () => {
    const routine = RoutineMother.create({ userId });
    const routineId = routine.toPrimitives().id;
    repository.returnOnSearch(routine);
    const newBlocks = [RoutineMother.blockPrimitives()];

    await usecase.execute(
      { userId, routineId },
      { name: "Updated", description: "New desc", blocks: newBlocks },
    );

    expect(repository.save).toHaveBeenCalledTimes(1);
    const saved = (repository.save as ReturnType<typeof import("bun:test").mock>).mock.calls[0][0];
    const primitives = saved.toPrimitives();
    expect(primitives.name).toBe("Updated");
    expect(primitives.description).toBe("New desc");
    expect(primitives.blocks).toEqual(newBlocks);
  });

  it("rejects if routine does not exist", async () => {
    const routineId = RoutineIdMother.random().value;
    repository.returnOnSearch(null);

    await expect(
      usecase.execute({ userId, routineId }, { name: "New Name" }),
    ).rejects.toThrow(RoutineDoesNotExistError);
  });

  it("rejects if routine does not belong to user", async () => {
    const routine = RoutineMother.create({ userId: "other-user" });
    const routineId = routine.toPrimitives().id;
    repository.returnOnSearch(routine);

    await expect(
      usecase.execute({ userId, routineId }, { name: "New Name" }),
    ).rejects.toThrow(UnauthorizedResourceAccessError);
  });
});
```

#### `tests/contexts/training/routines/application/delete-routine.test.ts`

```typescript
import { describe, it, expect, beforeEach } from "bun:test";
import { DeleteRoutine } from "../../../../../src/contexts/training/routines/application/delete-routine.usecase";
import { FindRoutine } from "../../../../../src/contexts/training/routines/domain/find-routine.usecase";
import { RoutineDoesNotExistError } from "../../../../../src/contexts/training/routines/domain/routine-does-not-exist-error";
import { UnauthorizedResourceAccessError } from "../../../../../src/shared/domain/unauthorized-resource-access-error";
import { RoutineMother } from "../domain/routine-mother";
import { RoutineIdMother } from "../domain/routine-id-mother";
import { MockRoutineRepository } from "../domain/mock-routine-repository";

describe("DeleteRoutine", () => {
  const userId = "user-1";

  let repository: MockRoutineRepository;
  let findRoutine: FindRoutine;
  let usecase: DeleteRoutine;

  beforeEach(() => {
    repository = new MockRoutineRepository();
    findRoutine = new FindRoutine(repository);
    usecase = new DeleteRoutine(repository, findRoutine);
  });

  it("finds routine, verifies ownership, and deletes", async () => {
    const routine = RoutineMother.create({ userId });
    const routineId = routine.toPrimitives().id;
    repository.returnOnSearch(routine);

    await usecase.execute({ userId, routineId });

    expect(repository.delete).toHaveBeenCalledTimes(1);
  });

  it("rejects if routine does not exist", async () => {
    const routineId = RoutineIdMother.random().value;
    repository.returnOnSearch(null);

    await expect(
      usecase.execute({ userId, routineId }),
    ).rejects.toThrow(RoutineDoesNotExistError);
  });

  it("rejects if routine does not belong to user", async () => {
    const routine = RoutineMother.create({ userId: "other-user" });
    const routineId = routine.toPrimitives().id;
    repository.returnOnSearch(routine);

    await expect(
      usecase.execute({ userId, routineId }),
    ).rejects.toThrow(UnauthorizedResourceAccessError);
  });
});
```

### Domain Layer

#### `src/contexts/training/routines/domain/routine-does-not-exist-error.ts`

```typescript
import { DomainError } from "../../../../shared/domain/domain-error";

export class RoutineDoesNotExistError extends DomainError {
  readonly type = "RoutineDoesNotExistError";
  readonly message: string;

  constructor(public readonly routineId: string) {
    super();
    this.message = `The routine ${this.routineId} does not exist`;
  }
}
```

#### `src/contexts/training/routines/domain/routine.ts` — UPDATE

Add the following four methods to the `Routine` class, after `toPrimitives()`:

```typescript
belongsTo(userId: string): boolean {
  return this.userId.value === userId;
}

updateName(name: string): void {
  this.name = new RoutineName(name);
  this.updatedAt = new Date();
}

updateDescription(description: string | null): void {
  this.description = description ? new RoutineDescription(description) : null;
  this.updatedAt = new Date();
}

updateBlocks(blocks: RoutineBlockPrimitives[]): void {
  this.blocks = blocks.map(RoutineBlock.fromPrimitives);
  this.updatedAt = new Date();
}
```

#### `src/contexts/training/routines/domain/find-routine.usecase.ts`

```typescript
import { InferDependencies } from "../../../../di/autoregister";
import type { Routine } from "./routine";
import { RoutineDoesNotExistError } from "./routine-does-not-exist-error";
import { RoutineId } from "./routine-id";
import { RoutineRepository } from "./routine-repository";

@InferDependencies()
export class FindRoutine {
  constructor(private readonly repository: RoutineRepository) {}

  async execute(params: { id: string }): Promise<Routine> {
    const routineId = new RoutineId(params.id);
    const routine = await this.repository.search(routineId);

    if (!routine) {
      throw new RoutineDoesNotExistError(params.id);
    }

    return routine;
  }
}
```

### Application Layer

#### `src/contexts/training/routines/application/search-routines-by-user.usecase.ts`

```typescript
import { InferDependencies } from "../../../../di/autoregister";
import { UserId } from "../../users/domain/user-id";
import type { RoutinePrimitives } from "../domain/routine";
import { RoutineRepository } from "../domain/routine-repository";

@InferDependencies()
export class SearchRoutinesByUser {
  constructor(private readonly repository: RoutineRepository) {}

  async execute(params: { userId: string }): Promise<RoutinePrimitives[]> {
    const userId = new UserId(params.userId);
    const routines = await this.repository.searchByUserId(userId);
    return routines.map((routine) => routine.toPrimitives());
  }
}
```

#### `src/contexts/training/routines/application/create-routine.usecase.ts`

```typescript
import { InferDependencies } from "../../../../di/autoregister";
import { Routine } from "../domain/routine";
import { RoutineRepository } from "../domain/routine-repository";
import type { RoutineBlockPrimitives } from "../domain/routine-block";

@InferDependencies()
export class CreateRoutine {
  constructor(private readonly repository: RoutineRepository) {}

  async execute(payload: {
    id: string;
    userId: string;
    name: string;
    description: string | null;
    blocks: RoutineBlockPrimitives[];
  }): Promise<void> {
    const routine = Routine.create({
      id: payload.id,
      userId: payload.userId,
      name: payload.name,
      description: payload.description,
      blocks: payload.blocks,
    });

    await this.repository.save(routine);
  }
}
```

#### `src/contexts/training/routines/application/update-routine.usecase.ts`

```typescript
import { InferDependencies } from "../../../../di/autoregister";
import { UnauthorizedResourceAccessError } from "../../../shared/domain/unauthorized-resource-access-error";
import { Routine } from "../domain/routine";
import { RoutineRepository } from "../domain/routine-repository";
import { FindRoutine } from "../domain/find-routine.usecase";
import type { RoutineBlockPrimitives } from "../domain/routine-block";

export type UpdateRoutineParams = {
  userId: string;
  routineId: string;
};

export type UpdateRoutinePayload = {
  name?: string;
  description?: string | null;
  blocks?: RoutineBlockPrimitives[];
};

@InferDependencies()
export class UpdateRoutine {
  constructor(
    private readonly repository: RoutineRepository,
    private readonly findRoutine: FindRoutine,
  ) {}

  async execute(
    params: UpdateRoutineParams,
    payload: UpdateRoutinePayload,
  ): Promise<void> {
    const routine = await this.findRoutine.execute({ id: params.routineId });

    this.ensureRoutineBelongsToUser(routine, params.routineId, params.userId);
    this.applyUpdates(routine, payload);

    await this.repository.save(routine);
  }

  private applyUpdates(
    routine: Routine,
    payload: UpdateRoutinePayload,
  ): void {
    type PayloadHandlers = {
      [K in keyof Required<UpdateRoutinePayload>]: (
        value: Exclude<UpdateRoutinePayload[K], undefined>,
      ) => void;
    };

    const handlers = {
      name: (v) => routine.updateName(v),
      description: (v) => routine.updateDescription(v),
      blocks: (v) => routine.updateBlocks(v),
    } satisfies PayloadHandlers;

    for (const [key, handler] of Object.entries(handlers)) {
      const value = payload[key as keyof UpdateRoutinePayload];
      if (value !== undefined) {
        handler(value as never);
      }
    }
  }

  private ensureRoutineBelongsToUser(
    routine: Routine,
    routineId: string,
    userId: string,
  ): void {
    if (routine.belongsTo(userId)) return;
    throw new UnauthorizedResourceAccessError(Routine, routineId);
  }
}
```

#### `src/contexts/training/routines/application/delete-routine.usecase.ts`

```typescript
import { InferDependencies } from "../../../../di/autoregister";
import { UnauthorizedResourceAccessError } from "../../../shared/domain/unauthorized-resource-access-error";
import { Routine } from "../domain/routine";
import { RoutineId } from "../domain/routine-id";
import { RoutineRepository } from "../domain/routine-repository";
import { FindRoutine } from "../domain/find-routine.usecase";

@InferDependencies()
export class DeleteRoutine {
  constructor(
    private readonly repository: RoutineRepository,
    private readonly findRoutine: FindRoutine,
  ) {}

  async execute(params: { userId: string; routineId: string }): Promise<void> {
    const routine = await this.findRoutine.execute({ id: params.routineId });

    this.ensureRoutineBelongsToUser(routine, params.routineId, params.userId);

    await this.repository.delete(new RoutineId(params.routineId));
  }

  private ensureRoutineBelongsToUser(
    routine: Routine,
    routineId: string,
    userId: string,
  ): void {
    if (routine.belongsTo(userId)) return;
    throw new UnauthorizedResourceAccessError(Routine, routineId);
  }
}
```
